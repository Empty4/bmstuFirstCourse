### 1. Производные классы, статусы доступа наследуемых полей и методов в производных классах  
**Производный класс** – это класс, который наследует свойства и методы от **базового класса**.  

**Статусы доступа при наследовании:**  
- `public`:  
  - Публичные члены базового класса остаются публичными в производном.  
  - Защищённые остаются защищёнными.  
  - Приватные **недоступны**.  
- `protected`:  
  - Публичные и защищённые члены базового класса становятся **защищёнными** в производном.  
  - Приватные **недоступны**.  
- `private` (по умолчанию для `class`, если не указано):  
  - Публичные и защищённые члены базового класса становятся **приватными** в производном.  
  - Приватные **недоступны**.  

**Пример:**  
```cpp
class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derived : public Base {
    // publicVar - public
    // protectedVar - protected
    // privateVar - недоступен
};
```

---

### 2. Особенности конструкторов в производных классах  
Конструкторы **не наследуются**. При создании объекта производного класса:  
1. Сначала вызывается конструктор **базового класса**.  
2. Затем конструктор **производного класса**.  

**Пример:**  
```cpp
class Base {
public:
    Base() { cout << "Base constructor\n"; }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor\n"; }
};

int main() {
    Derived d; // Вывод: Base constructor → Derived constructor
}
```
**Если базовый класс требует параметры:**  
```cpp
Derived(int x) : Base(x) { ... } // Явный вызов конструктора Base
```

---

### 3. Особенности деструкторов в производных классах  
Деструкторы вызываются в **обратном порядке**:  
1. Сначала деструктор **производного класса**.  
2. Затем деструктор **базового класса**.  

**Пример:**  
```cpp
class Base {
public:
    ~Base() { cout << "Base destructor\n"; }
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived destructor\n"; }
};

int main() {
    Derived d; 
} // Вывод: Derived destructor → Base destructor
```

**Важно:** Если базовый класс имеет **виртуальный деструктор**, то через указатель на базовый класс будет вызван правильный деструктор:  
```cpp
virtual ~Base() {} // Теперь ~Derived() вызовется даже при delete basePtr;
```

---

### 4. Переопределение функций в производных классах, виртуальные функции  
- **Переопределение (override):** Замена реализации метода базового класса в производном.  
- **Виртуальные функции (`virtual`):** Позволяют **динамическое связывание** (выбор метода во время выполнения).  

**Пример:**  
```cpp
class Base {
public:
    virtual void show() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived\n"; } // Переопределение
};

int main() {
    Base* b = new Derived();
    b->show(); // Вывод: "Derived" (без virtual было бы "Base")
}
```

---

### 5. Статическое и динамическое связывание  
- **Статическое (раннее):** Выбор метода на этапе компиляции (по типу указателя).  
- **Динамическое (позднее):** Выбор метода во время выполнения (через `virtual`).  

**Пример:**  
```cpp
Base* b = new Derived();
b->show(); // Динамическое, если show() виртуальный
```

---

### 6. Ключевое слово `final`  
Запрещает дальнейшее наследование или переопределение метода:  
```cpp
class Base final { }; // Нельзя наследовать
class Derived : public Base { }; // Ошибка!

class Base {
public:
    virtual void foo() final { }
};

class Derived : public Base {
    void foo() override { } // Ошибка! foo() - final
};
```

---

### 7. Ключевое слово `override`  
Указывает, что метод **должен переопределять виртуальный метод базового класса**. Если такого метода нет – ошибка компиляции.  
```cpp
class Derived : public Base {
    void show() override { ... } // OK, если Base::show() виртуальный
    void print() override { ... } // Ошибка, если Base::print() не существует
};
```

---

### 8. Множественное наследование и виртуальные базовые классы  
**Множественное наследование:** Класс может наследовать от нескольких базовых.  
**Проблема:** "Ромбовидное наследование" (дублирование базового класса).  

**Решение:** `virtual`-наследование.  
```cpp
class A { };
class B : virtual public A { };
class C : virtual public A { };
class D : public B, public C { }; // Теперь A в D только один
```

---

### 9. Абстрактные и локальные классы  
**Абстрактный класс:** Содержит хотя бы одну **чистую виртуальную функцию** (`= 0`). Нельзя создать объект.  
```cpp
class Abstract {
public:
    virtual void foo() = 0; // Чистая виртуальная
};

class Concrete : public Abstract {
    void foo() override { } // Реализация
};
```

**Локальный класс:** Класс, объявленный внутри функции. Видит только статические переменные функции.  
```cpp
void func() {
    static int x = 10;
    class Local {
    public:
        void print() { cout << x; } // OK
    };
    Local l;
    l.print();
}
```

---

### Итог  
- Наследование позволяет расширять классы, контролируя доступ через `public/protected/private`.  
- Конструкторы/деструкторы вызываются в определённом порядке.  
- Виртуальные функции (`virtual`, `override`, `final`) управляют полиморфизмом.  
- Множественное наследование требует осторожности (виртуальные базовые классы).  
- Абстрактные классы задают интерфейс, локальные – ограниченную область видимости.